# libbpf Fundamentals

## Overview

libbpf is the **standard library for eBPF development** that provides C APIs for loading, managing, and interacting with eBPF programs and maps. It's the foundation for production-grade eBPF applications used by Cilium, Katran, and other major projects.

---

## Why libbpf?

### Advantages

| Feature | Benefit |
|---------|---------|
| **CO-RE Support** | Write once, run on any kernel (portable) |
| **Type Safety** | BPF skeletons provide compile-time type checking |
| **Performance** | No Python overhead like BCC |
| **Production Ready** | Used by major cloud providers |
| **Standard Library** | Official kernel userspace library |
| **Small Footprint** | Minimal dependencies, easy to deploy |

### libbpf vs BCC

```
┌────────────────────────────────────────────────────────────┐
│                    BCC vs libbpf                           │
├────────────────────────────────────────────────────────────┤
│                                                             │
│  BCC:                                                       │
│  ✓ Rapid prototyping                                       │
│  ✓ Python/Lua bindings                                     │
│  ✗ Runtime compilation (needs LLVM)                        │
│  ✗ Large dependencies                                       │
│  ✗ Not suitable for embedded/production                    │
│                                                             │
│  libbpf:                                                    │
│  ✓ Pre-compiled BPF programs                               │
│  ✓ Small footprint                                          │
│  ✓ Production deployment                                    │
│  ✓ CO-RE portability                                        │
│  ✗ More boilerplate code                                    │
│  ✗ Steeper learning curve                                   │
│                                                             │
└────────────────────────────────────────────────────────────┘
```

---

## Architecture

### Development Workflow

```
┌─────────────────────────────────────────────────────────────┐
│  libbpf Development Workflow                                │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  1. Write BPF program (*.bpf.c)                             │
│     ↓                                                        │
│  2. Compile with clang -target bpf                          │
│     ↓                                                        │
│  3. Generate skeleton (bpftool gen skeleton)                │
│     ↓                                                        │
│  4. Write user-space loader (*.c)                           │
│     ↓                                                        │
│  5. Link with libbpf                                         │
│     ↓                                                        │
│  6. Deploy single binary (no runtime dependencies)          │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### File Structure

```
my-ebpf-project/
├── src/
│   ├── my_program.bpf.c       # BPF program (kernel-side)
│   ├── my_program.c           # User-space loader
│   └── my_program.h           # Shared definitions
├── vmlinux.h                   # Kernel types (BTF)
├── Makefile
└── output/
    ├── my_program.bpf.o       # Compiled BPF object
    ├── my_program.skel.h      # Generated skeleton
    └── my_program             # Final binary
```

---

## Core Concepts

### 1. BPF Objects (.bpf.o)

Compiled eBPF programs in ELF format containing:
- BPF bytecode instructions
- BTF type information
- Map definitions
- Program metadata

```c
// Example: hello.bpf.c
#include <linux/bpf.h>
#include <bpf/bpf_helpers.h>

SEC("tracepoint/syscalls/sys_enter_execve")
int handle_execve(struct trace_event_raw_sys_enter *ctx)
{
    char comm[16];
    bpf_get_current_comm(&comm, sizeof(comm));
    bpf_printk("execve: %s\n", comm);
    return 0;
}

char LICENSE[] SEC("license") = "GPL";
```

### 2. Skeletons (.skel.h)

Auto-generated C headers providing type-safe APIs:

```c
// Generated by: bpftool gen skeleton hello.bpf.o > hello.skel.h

struct hello_bpf {
    struct bpf_object_skeleton *skeleton;
    struct bpf_object *obj;
    struct {
        struct bpf_program *handle_execve;
    } progs;
    struct {
        struct bpf_link *handle_execve;
    } links;
};

// Auto-generated functions:
struct hello_bpf *hello_bpf__open(void);
int hello_bpf__load(struct hello_bpf *obj);
int hello_bpf__attach(struct hello_bpf *obj);
void hello_bpf__destroy(struct hello_bpf *obj);
```

### 3. User-Space Loader

```c
// hello.c - User-space program
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <bpf/libbpf.h>
#include "hello.skel.h"

static volatile bool exiting = false;

static void sig_handler(int sig) {
    exiting = true;
}

int main(void) {
    struct hello_bpf *skel;
    int err;

    // Open BPF application
    skel = hello_bpf__open();
    if (!skel) {
        fprintf(stderr, "Failed to open BPF skeleton\n");
        return 1;
    }

    // Load & verify BPF programs
    err = hello_bpf__load(skel);
    if (err) {
        fprintf(stderr, "Failed to load BPF skeleton: %d\n", err);
        goto cleanup;
    }

    // Attach tracepoints
    err = hello_bpf__attach(skel);
    if (err) {
        fprintf(stderr, "Failed to attach BPF programs: %d\n", err);
        goto cleanup;
    }

    signal(SIGINT, sig_handler);
    printf("Successfully started! Press Ctrl+C to stop.\n");

    while (!exiting) {
        sleep(1);
    }

cleanup:
    hello_bpf__destroy(skel);
    return err;
}
```

---

## libbpf API Categories

### 1. Object Lifecycle

```c
// Open: Parse BPF ELF object
struct bpf_object *bpf_object__open(const char *path);
struct bpf_object *bpf_object__open_mem(const void *obj_buf, size_t obj_buf_sz);

// Load: Verify and load into kernel
int bpf_object__load(struct bpf_object *obj);

// Close: Clean up
void bpf_object__close(struct bpf_object *obj);
```

### 2. Program Management

```c
// Find programs by name
struct bpf_program *bpf_object__find_program_by_name(struct bpf_object *obj, const char *name);

// Attach to hooks
struct bpf_link *bpf_program__attach(struct bpf_program *prog);
struct bpf_link *bpf_program__attach_tracepoint(struct bpf_program *prog,
                                                 const char *tp_category,
                                                 const char *tp_name);
struct bpf_link *bpf_program__attach_kprobe(struct bpf_program *prog,
                                             bool retprobe,
                                             const char *func_name);

// Detach
int bpf_link__destroy(struct bpf_link *link);
```

### 3. Map Operations

```c
// Find maps by name
struct bpf_map *bpf_object__find_map_by_name(struct bpf_object *obj, const char *name);

// Get map FD
int bpf_map__fd(const struct bpf_map *map);

// Lookup/Update/Delete
int bpf_map_lookup_elem(int fd, const void *key, void *value);
int bpf_map_update_elem(int fd, const void *key, const void *value, __u64 flags);
int bpf_map_delete_elem(int fd, const void *key);

// Iteration
int bpf_map_get_next_key(int fd, const void *key, void *next_key);
```

### 4. Ring Buffer

```c
// Create ring buffer manager
struct ring_buffer *ring_buffer__new(int map_fd, ring_buffer_sample_fn sample_cb,
                                      void *ctx, const struct ring_buffer_opts *opts);

// Poll for events
int ring_buffer__poll(struct ring_buffer *rb, int timeout_ms);

// Consume events
int ring_buffer__consume(struct ring_buffer *rb);

// Free
void ring_buffer__free(struct ring_buffer *rb);
```

---

## Build System

### Makefile Example

```makefile
# Minimal Makefile for libbpf program

CLANG ?= clang
BPFTOOL ?= bpftool
LIBBPF_INCLUDES = -I/usr/include
LIBBPF_LIBS = -lbpf -lelf -lz

# BPF program name
PROGRAM = hello

# Targets
.PHONY: all clean

all: $(PROGRAM)

# Generate vmlinux.h (kernel types)
vmlinux.h:
	$(BPFTOOL) btf dump file /sys/kernel/btf/vmlinux format c > $@

# Compile BPF program
$(PROGRAM).bpf.o: $(PROGRAM).bpf.c vmlinux.h
	$(CLANG) -g -O2 -target bpf -D__TARGET_ARCH_x86_64 \
		$(LIBBPF_INCLUDES) -c $< -o $@

# Generate skeleton
$(PROGRAM).skel.h: $(PROGRAM).bpf.o
	$(BPFTOOL) gen skeleton $< > $@

# Compile user-space program
$(PROGRAM): $(PROGRAM).c $(PROGRAM).skel.h
	$(CLANG) -g -Wall $(LIBBPF_INCLUDES) $< -o $@ $(LIBBPF_LIBS)

clean:
	rm -f $(PROGRAM) $(PROGRAM).bpf.o $(PROGRAM).skel.h vmlinux.h
```

---

## Common Patterns

### Pattern 1: Global Variables

```c
// BPF side (my_prog.bpf.c)
volatile const int filter_pid = 0;  // Can be set from userspace

SEC("kprobe/sys_execve")
int kprobe_execve(struct pt_regs *ctx) {
    int pid = bpf_get_current_pid_tgid() >> 32;
    if (filter_pid && pid != filter_pid)
        return 0;

    // Process event...
    return 0;
}

// User-space side
int main(void) {
    struct my_prog_bpf *skel;

    skel = my_prog_bpf__open();

    // Set global variable before loading
    skel->rodata->filter_pid = 1234;

    my_prog_bpf__load(skel);
    my_prog_bpf__attach(skel);
    // ...
}
```

### Pattern 2: Per-CPU Arrays for Performance

```c
// BPF side
struct {
    __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __uint(max_entries, 1);
    __type(key, __u32);
    __type(value, struct event);
} heap SEC(".maps");

SEC("kprobe/sys_read")
int kprobe_read(struct pt_regs *ctx) {
    __u32 zero = 0;
    struct event *e = bpf_map_lookup_elem(&heap, &zero);
    if (!e)
        return 0;

    // Use per-CPU scratch space (no lock contention)
    e->pid = bpf_get_current_pid_tgid() >> 32;
    // ...

    return 0;
}
```

### Pattern 3: Ring Buffer Events

```c
// BPF side
struct {
    __uint(type, BPF_MAP_TYPE_RINGBUF);
    __uint(max_entries, 256 * 1024);  // 256KB
} events SEC(".maps");

SEC("tracepoint/syscalls/sys_enter_openat")
int handle_openat(struct trace_event_raw_sys_enter *ctx) {
    struct event *e;

    e = bpf_ringbuf_reserve(&events, sizeof(*e), 0);
    if (!e)
        return 0;

    e->pid = bpf_get_current_pid_tgid() >> 32;
    bpf_get_current_comm(&e->comm, sizeof(e->comm));
    // Fill event...

    bpf_ringbuf_submit(e, 0);
    return 0;
}

// User-space side
static int handle_event(void *ctx, void *data, size_t data_sz) {
    struct event *e = data;
    printf("PID %d opened file: %s\n", e->pid, e->filename);
    return 0;
}

int main(void) {
    struct my_prog_bpf *skel;
    struct ring_buffer *rb;

    skel = my_prog_bpf__open_and_load();
    my_prog_bpf__attach(skel);

    rb = ring_buffer__new(bpf_map__fd(skel->maps.events), handle_event, NULL, NULL);

    while (!exiting) {
        ring_buffer__poll(rb, 100 /* timeout_ms */);
    }

    ring_buffer__free(rb);
    my_prog_bpf__destroy(skel);
}
```

---

## Error Handling

### libbpf Logging

```c
#include <bpf/libbpf.h>

static int libbpf_print_fn(enum libbpf_print_level level, const char *format, va_list args)
{
    return vfprintf(stderr, format, args);
}

int main(void) {
    // Set custom log handler
    libbpf_set_print(libbpf_print_fn);

    // Now libbpf will print detailed errors
    struct bpf_object *obj = bpf_object__open("my_prog.bpf.o");
    if (libbpf_get_error(obj)) {
        fprintf(stderr, "Failed to open BPF object\n");
        return 1;
    }
    // ...
}
```

### Common Errors

| Error | Cause | Solution |
|-------|-------|----------|
| `libbpf: failed to find BTF` | BTF not available | Generate vmlinux.h or use fallback |
| `Invalid argument` during load | Verifier rejection | Enable libbpf debug logs |
| `Permission denied` | Missing capabilities | Run with CAP_BPF or root |
| `No such file or directory` | BPF object not found | Check file path |
| `Cannot allocate memory` | Large BPF program | Reduce program size or increase RLIMIT_MEMLOCK |

---

## Best Practices

### 1. Always Check Return Values

```c
// Bad
hello_bpf__load(skel);
hello_bpf__attach(skel);

// Good
if (hello_bpf__load(skel)) {
    fprintf(stderr, "Load failed\n");
    goto cleanup;
}
if (hello_bpf__attach(skel)) {
    fprintf(stderr, "Attach failed\n");
    goto cleanup;
}
```

### 2. Use Skeletons for Type Safety

```c
// Avoid manual APIs when skeleton is available
// Bad: Manual API
struct bpf_object *obj = bpf_object__open("prog.bpf.o");
struct bpf_program *prog = bpf_object__find_program_by_name(obj, "handle_exec");

// Good: Skeleton
struct prog_bpf *skel = prog_bpf__open();
struct bpf_program *prog = skel->progs.handle_exec;  // Type-safe
```

### 3. Enable Debug Logs During Development

```c
libbpf_set_print(libbpf_print_fn);  // See verifier errors
```

### 4. Set Resource Limits

```c
#include <sys/resource.h>

// Increase locked memory limit (older kernels)
struct rlimit rlim = {
    .rlim_cur = 512UL << 20,  // 512 MB
    .rlim_max = 512UL << 20,
};
setrlimit(RLIMIT_MEMLOCK, &rlim);
```

---

## Debugging Tips

### 1. Verifier Logs

```c
// Set strict log level
LIBBPF_OPTS(bpf_object_open_opts, opts,
    .kernel_log_level = 1 | 2 | 4,  // Stats, verifier, logs
);

struct bpf_object *obj = bpf_object__open_file("prog.bpf.o", &opts);
```

### 2. bpftool Inspection

```bash
# List loaded programs
sudo bpftool prog list

# Show program details
sudo bpftool prog show id <ID>

# Dump program instructions
sudo bpftool prog dump xlated id <ID>

# Show map contents
sudo bpftool map dump id <ID>
```

### 3. Check BTF

```bash
# Verify BTF is available
ls /sys/kernel/btf/vmlinux

# Check if program has BTF
readelf -S my_prog.bpf.o | grep BTF
```

---

## Performance Considerations

### Map Type Selection

| Use Case | Recommended Map Type |
|----------|---------------------|
| Counters/stats | `BPF_MAP_TYPE_PERCPU_ARRAY` |
| Event streaming | `BPF_MAP_TYPE_RINGBUF` |
| Key-value lookup | `BPF_MAP_TYPE_HASH` |
| Per-process data | `BPF_MAP_TYPE_HASH` (key = PID) |
| Scratch space | `BPF_MAP_TYPE_PERCPU_ARRAY` |
| Large datasets | `BPF_MAP_TYPE_LRU_HASH` |

### Ring Buffer vs Perf Buffer

```
Ring Buffer (preferred):
✓ Better performance
✓ Memory efficient
✓ Easier API
✓ Built-in backpressure

Perf Buffer (legacy):
✗ Per-CPU overhead
✗ More complex
✓ Compatible with older kernels (<5.8)
```

---

## Next Steps

After mastering libbpf fundamentals:
1. Learn **CO-RE (Compile Once, Run Everywhere)** for portability
2. Understand **BPF skeletons** in depth
3. Master **verifier constraints** and debugging
4. Explore **advanced map types** (LRU, LPM trie, etc.)
5. Study **production deployment** patterns

---

## References

- [libbpf GitHub](https://github.com/libbpf/libbpf)
- [libbpf API Documentation](https://libbpf.readthedocs.io/)
- [Kernel BPF Documentation](https://www.kernel.org/doc/html/latest/bpf/)
- [Cilium BPF Reference](https://docs.cilium.io/en/stable/bpf/)
